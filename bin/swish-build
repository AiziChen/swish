#!/usr/bin/env swish

(define-tuple <args> boot-files libdirs rt-libs source-fn output-fn shebang? libs-visible? verbose?)

(define swish-lib?
  (let ([libs (filter (lambda (lib) (match lib [(swish . ,_) #t] [,_ #f])) (library-list))])
    (lambda (lib)
      (member lib libs))))

(define swish-libdir (path-parent (osi_get_executable_path)))

(define (system-libdir swish-wpo?)
  (path-combine swish-libdir (if swish-wpo? "wpo" "lib")))

(define swish-library-filename
  (get-real-path (path-combine swish-libdir "swish.library")))

(define (library-setup swish-wpo? verbose? libdirs)
  (library-directories (cons (system-libdir swish-wpo?) libdirs))
  (when verbose?
    (printf "Library directories:\n~{ ~s\n~}" (library-directories))))

(define who (path-last (car (command-line))))

(define (fail fmt . args) (apply errorf who fmt args))

(define (default-args)
  (<args> make
    [boot-files '()]
    [libdirs (library-directories)]
    [rt-libs '()]
    [source-fn #f]
    [output-fn #f]
    [shebang? #t]
    [libs-visible? #f]
    [verbose? #f]))

(define (usage doc-type)
  (case doc-type
    [(all help)
     (printf "Usage: ~a [option] ... source-fn\n" who)
     (printf "Options:\n")
     (printf "  -o out-file     write output to out-file\n")
     (printf "  -L libdir       add libdir to library-directories\n")
     (printf "  -b boot-file    make stand-alone application including boot-file\n")
     (printf "  --libs-visible  make imported libraries visible to eval\n")
     (printf "  --rtlib lib     add compiled library to stand-alone boot file\n")
     (printf "  -v              enable verbose build output\n")
     (printf "  --help          show this help\n")
     (printf "  --doc <type>    show doc <type>={all|help|details|examples}\n")
     (newline)])
  (case doc-type
    [(all details)
     (printf "~a can make a stand-alone application or a linked application.\n" who)
     (newline)
     (printf "If -b is specified, ~a creates a stand-alone application\n" who)
     (printf "by copying the ~a executable to <out-file> and creating a boot\n" software-internal-name)
     (printf "file <out-file>.boot containing each -b boot-file in order, along\n")
     (printf "with the libraries required by source-fn and the application code\n")
     (printf "from source-fn, and the run-time libraries included via --rtlib.\n")
     (newline)
     (printf "A stand-alone application executes by:\n")
     (printf "  1. loading the application boot file, then\n")
     (printf "  2. invoking the value of the swish-start parameter\n")
     (printf "     with the command-line arguments.\n")
     (printf "The application boot file should customize the swish-start parameter.\n")
     (newline)
     (printf "If -b is omitted, ~a creates a linked application.\n" who)
     (printf "To run a linked application, ~a must be installed on the system.\n" software-internal-name)
     (printf "A linked application executes by:\n")
     (printf "  1. loading the standard ~a boot file, then\n" software-internal-name)
     (printf "  2. invoking the default swish-start handler, which\n")
     (printf "  3. calls the linked application with the command-line arguments.\n")
     (newline)])
  (case doc-type
    [(all examples)
     (printf "Examples:\n")
     (newline)
     (printf "  ~a -o foo -b petite foo.ss\n" who)
     (printf "     builds a stand-alone \"foo\" executable from \"foo.ss\"\n")
     (printf "     using the same petite.boot that swish uses\n")
     (newline)
     (printf "  ~a -o foo -b petite -b scheme foo.ss\n" who)
     (printf "     builds a stand-alone \"foo\" executable from \"foo.ss\"\n")
     (printf "     using the same petite.boot and scheme.boot that swish uses\n")
     (printf "     (if we specified only -b scheme, the resulting foo.boot would\n")
     (printf "     not be truly stand-alone, since scheme.boot requires petite.boot)\n")
     (newline)
     (printf "  ~a -o foo -b petite -b scheme --rtlib swish foo.ss\n" who)
     (printf "     builds a stand-alone \"foo\" executable from \"foo.ss\"\n")
     (printf "     using the same petite.boot and scheme.boot that swish uses\n")
     (printf "     and makes the standard swish libraries available at run time, so\n")
     (printf "     that \"foo\" can compile code that uses those libraries.\n")]
    [(help) (void)]
    [else (fail "unrecognized --doc ~a" doc-type)])
  (exit 0))

(define (parse-library lib)
  (parameterize ([library-directories lib])
    (library-directories)))

(define-syntax match-required
  (syntax-rules ()
    [(_ args clause ...)
     (match args
       [(,option . ,more)
        (define (need-arg) (fail "~a requires an argument; see --help" option))
        (match more
          [() (need-arg)]
          [(,option . ,_)
           (guard (starts-with? option "--"))
           (need-arg)]
          clause ...)])]))

(define (parse-args args)
  (when (null? args) (usage 'help))
  (let parse ([args args]
              [acc (default-args)])
    (match args
      [() acc]
      [("--help" . ,_) (usage 'help)]
      [("--doc" . ,_)
       (match-required args
         [(,doc-type . ,_) (usage (string->symbol doc-type))])]
      [("-L" . ,_)
       (match-required args
         [(,lib . ,more)
          (<args> copy* (parse more acc)
            [libdirs (append (parse-library lib) libdirs)])])]
      [("-b" . ,_)
       (match-required args
         [(,boot-file . ,more)
          (<args> copy* (parse more acc)
            [boot-files (cons boot-file boot-files)]
            [shebang? #f])])]
      [("-o" . ,_)
       (match-required args
         [(,output-fn . ,more)
          (if (<args> output-fn acc)
              (fail "duplicate -o ~a" output-fn)
              (parse more (<args> copy acc [output-fn output-fn])))])]
      [("--libs-visible" . ,more)
       (parse more (<args> copy acc [libs-visible? #t]))]
      [("-v" . ,more)
       (parse more (<args> copy acc [verbose? #t]))]
      [("--rtlib" . ,_)
       (match-required args
         [(,lib . ,more)
          (<args> copy* (parse more acc)
            [rt-libs (cons (get-real-path (resolve-rt-lib lib)) rt-libs)])])]
      [(,other . ,unexpected)
       (guard (starts-with? other "-"))
       (fail "unexpected ~a~{ ~a~}; see --help" other unexpected)]
      [(,source-fn . ,more)
       (if (<args> source-fn acc)
           (fail "extra input filename ~a" source-fn)
           (parse more (<args> copy acc [source-fn source-fn])))])))

;; create tmp file:
;;  - on the same filesystem as basis, else rename-path will fail
;;  - with known extension, since compile-whole-program replaces
;;    extension with .wpo
(define (tmp-filename basis)
  (format "~a-~36r.tmp" (path-root basis)
    (bytevector-uint-ref (osi_make_uuid) 0 'little 16)))

(define (copy ip op)
  (define buflen (expt 2 16))
  (define buf (make-bytevector buflen))
  (let cp ()
    (let ([n (get-bytevector-n! ip buf 0 buflen)])
      (unless (eof-object? n)
        (put-bytevector op buf 0 n)
        (cp)))))

(define (copy-to output-fn . input-fn*)
  ;; open-file applies mode #o777 only when creating the file, so first remove
  (rm-f output-fn)
  (let ([op (open-file output-fn (+ O_WRONLY O_CREAT) #o777 'binary-output)])
    (on-exit (close-port op)
      (for-each
       (lambda (input-fn)
         (let ([ip (open-file input-fn O_RDONLY 0 'binary-input)])
           (on-exit (close-port ip)
             (copy ip op))))
       input-fn*))))

(define (rm-f filename)
  (catch (remove-file filename)))

(define (do-compile source-fn output-fn libs-visible? swish-wpo?)
  (let ([tmp (tmp-filename source-fn)])
    (on-exit (rm-f tmp)
      (compile-imported-libraries #t)
      (generate-wpo-files #t)
      (compile-program source-fn tmp)
      (let* ([wpo-file (string-append (path-root tmp) ".wpo")]
             [libs (compile-whole-program wpo-file output-fn libs-visible?)]
             [missing-libs
              ;; Stand-alone application should have found all required non-swish libraries.
              ;; If swish libraries are incorporated via whole-program optimization,
              ;; then we must also have found the those libraries.
              ;; Dependent applications can use swish libraries included in runtime,
              ;; as can stand-alone applications that explicitly specify --rtlib swish.
              (if swish-wpo?
                  libs
                  (remp swish-lib? libs))])
        (rm-f wpo-file)
        (unless (null? missing-libs)
          (printf "These libraries must be provided at run time:\n~{ ~s\n~}" missing-libs))))))

(define boot-file-map
  (let ([cache #f])
    (lambda ()
      (unless cache
        (set! cache (build-boot-file-map)))
      cache)))

(define (build-boot-file-map)
  (let-values ([(to-stdin from-stdout from-stderr os-pid)
                (spawn-os-process (osi_get_executable_path) '("--verbose") self)])
    (close-port to-stdin)
    (let ([from-stderr (binary->utf8 from-stderr)])
      (let lp ([als '()])
        (let ([line (get-line from-stderr)])
          (if (eof-object? line)
              als
              (lp
               (match (pregexp-match "^trying (.*)\\.\\.\\.opened\r?$" line)
                 [(,_ ,fn)
                  (cons (cons (path-last fn) fn) als)]
                 [,_ als]))))))))

(define (resolve-boot-file boot)
  (cond
   [(regular-file? boot) boot]
   [(assoc boot (boot-file-map)) => cdr]
   [(assoc (string-append boot ".boot") (boot-file-map)) => cdr]
   [else (fail "cannot resolve boot file ~a" boot)]))

(define (resolve-rt-lib rt-lib)
  (cond
   [(regular-file? rt-lib) rt-lib]
   [(equal? rt-lib "swish") swish-library-filename]
   [else (fail "cannot resolve --rtlib ~s" rt-lib)]))

(match (parse-args (command-line-arguments))
  [`(<args> [source-fn #f])
   (fail "requires source filename; see --help")]
  [`(<args> [output-fn #f])
   (fail "requires output filename [-o file]; see --help")]
  [`(<args> ,boot-files ,libdirs ,source-fn ,output-fn ,shebang? ,libs-visible? ,rt-libs ,verbose?)
   (define stand-alone? (not (null? boot-files)))
   ;; Add location of swish system .wpo files only if we're building a
   ;; stand-alone application (boot-files non-empty).
   (import-notify verbose?)
   (cond
    [stand-alone?
     (let* ([boot-files (map resolve-boot-file boot-files)]
            [swish-wpo?
             (or (null? rt-libs)
                 ;; don't use wpo for swish library if we're including it as a
                 ;; run-time library, else we could duplicate code
                 (not (member swish-library-filename rt-libs)))])
       (library-setup swish-wpo? verbose? libdirs)
       (do-compile source-fn output-fn libs-visible? swish-wpo?)
       (let* ([app-stem (path-root output-fn)]
              [app-boot (string-append app-stem ".boot")])
         (when verbose?
           (printf "making application boot file ~s from:~{\n-b      ~s~}~{\n--rtlib ~s~}\n        ~s\n"
             app-boot boot-files rt-libs source-fn))
         (apply make-boot-file app-boot '() (append boot-files rt-libs (list output-fn)))
         (copy-to output-fn (osi_get_executable_path))))]
    [shebang?
     (library-setup #f verbose? libdirs)
     (do-compile source-fn output-fn libs-visible? #f)
     (let* ([tmp (tmp-filename output-fn)]
            [ip (open-file output-fn O_RDONLY 0 'binary-input)]
            [op (open-file tmp (+ O_WRONLY O_CREAT O_APPEND) #o777 'binary-output)])
       (on-exit (begin (close-port ip) (close-port op))
         (put-bytevector op (string->utf8 "#!/usr/bin/env swish\n"))
         (for-each
          (lambda (rt-lib)
            (unless (equal? rt-lib swish-library-filename)
              (let ([ip (open-file rt-lib O_RDONLY 0 'binary-input)])
                (on-exit (close-port ip)
                  (copy ip op)))))
          rt-libs)
         (copy ip op))
       (rename-path tmp output-fn))])])
