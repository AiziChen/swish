#!/usr/bin/env swish

;;; Copyright 2018 Beckman Coulter, Inc.
;;;
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use, copy,
;;; modify, merge, publish, distribute, sublicense, and/or sell copies
;;; of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.

(define cli
  (cli-specs
   ["output-file" -o (string "<output>") "write output to <output>"]
   ["libdirs" -L (list "<libdir>") "add <libdir> to library-directories"]
   ["boot-files" -b (list "<boot-file>")
    "make stand-alone application including <boot-file>"]
   ["libs-visible" --libs-visible bool
    "make imported libraries visible to eval"]
   ["rt-libs" --rtlib (list "<lib>")
    "add compiled library to stand-alone boot file"]
   ["source-file" (string "<source>") "source filename"]
   ["verbose" -v bool "enable verbose build output"]
   default-help
   ["doc" --doc (string "<type>")
    "show doc <type>={all|help|details|examples}"]))

(define swish-lib?
  (let ([libs (filter (lambda (lib) (match lib [(swish . ,_) #t] [,_ #f])) (library-list))])
    (lambda (lib)
      (member lib libs))))

(define swish-libdir (path-parent (osi_get_executable_path)))

(define (system-libdir swish-wpo?)
  (path-combine swish-libdir (if swish-wpo? "wpo" "lib")))

(define swish-library-filename
  (get-real-path (path-combine swish-libdir "swish.library")))

(define (library-setup swish-wpo? verbose? libdirs)
  (library-directories (cons (system-libdir swish-wpo?) libdirs))
  (when verbose?
    (printf "Library directories:\n~{ ~s\n~}" (library-directories))))

(define who (path-last (car (command-line))))

(define (fail fmt . args) (apply errorf who fmt args))

(define (usage doc-type ht)
  (case doc-type
    [(all help)
     (display-help who cli ht)
     (newline)])
  (case doc-type
    [(all details)
     (printf "~a can make a stand-alone application or a linked application.\n" who)
     (newline)
     (printf "If -b is specified, ~a creates a stand-alone application\n" who)
     (printf "by copying the ~a executable to <out-file> and creating a boot\n" software-internal-name)
     (printf "file <out-file>.boot containing each -b boot-file in order, along\n")
     (printf "with the libraries required by source-fn and the application code\n")
     (printf "from source-fn, and the run-time libraries included via --rtlib.\n")
     (newline)
     (printf "A stand-alone application executes by:\n")
     (printf "  1. loading the application boot file, then\n")
     (printf "  2. invoking the value of the swish-start parameter\n")
     (printf "     with the command-line arguments.\n")
     (printf "The application boot file should customize the swish-start parameter.\n")
     (newline)
     (printf "If -b is omitted, ~a creates a linked application.\n" who)
     (printf "To run a linked application, ~a must be installed on the system.\n" software-internal-name)
     (printf "A linked application executes by:\n")
     (printf "  1. loading the standard ~a boot file, then\n" software-internal-name)
     (printf "  2. invoking the default swish-start handler, which\n")
     (printf "  3. calls the linked application with the command-line arguments.\n")
     (newline)])
  (case doc-type
    [(all examples)
     (printf "Examples:\n")
     (newline)
     (printf "  ~a -o foo -b petite foo.ss\n" who)
     (printf "     builds a stand-alone \"foo\" executable from \"foo.ss\"\n")
     (printf "     using the same petite.boot that swish uses\n")
     (newline)
     (printf "  ~a -o foo -b petite -b scheme foo.ss\n" who)
     (printf "     builds a stand-alone \"foo\" executable from \"foo.ss\"\n")
     (printf "     using the same petite.boot and scheme.boot that swish uses\n")
     (printf "     (if we specified only -b scheme, the resulting foo.boot would\n")
     (printf "     not be truly stand-alone, since scheme.boot requires petite.boot)\n")
     (newline)
     (printf "  ~a -o foo -b petite -b scheme --rtlib swish foo.ss\n" who)
     (printf "     builds a stand-alone \"foo\" executable from \"foo.ss\"\n")
     (printf "     using the same petite.boot and scheme.boot that swish uses\n")
     (printf "     and makes the standard swish libraries available at run time, so\n")
     (printf "     that \"foo\" can compile code that uses those libraries.\n")]
    [(help) (void)]
    [else (fail "unrecognized --doc ~a" doc-type)])
  (exit 0))

(define (parse-library lib)
  (parameterize ([library-directories lib])
    (library-directories)))

;; create tmp file:
;;  - on the same filesystem as basis, else rename-path will fail
;;  - with known extension, since compile-whole-program replaces
;;    extension with .wpo
(define (tmp-filename basis)
  (format "~a-~36r.tmp" (path-root basis)
    (bytevector-uint-ref (osi_make_uuid) 0 'little 16)))

(define (copy ip op)
  (define buflen (expt 2 16))
  (define buf (make-bytevector buflen))
  (let cp ()
    (let ([n (get-bytevector-n! ip buf 0 buflen)])
      (unless (eof-object? n)
        (put-bytevector op buf 0 n)
        (cp)))))

(define (copy-to output-fn . input-fn*)
  ;; open-file applies mode #o777 only when creating the file, so first remove
  (rm-f output-fn)
  (let ([op (open-file output-fn (+ O_WRONLY O_CREAT) #o777 'binary-output)])
    (on-exit (close-port op)
      (for-each
       (lambda (input-fn)
         (let ([ip (open-file input-fn O_RDONLY 0 'binary-input)])
           (on-exit (close-port ip)
             (copy ip op))))
       input-fn*))))

(define (rm-f filename)
  (catch (remove-file filename)))

(define (do-compile source-fn output-fn libs-visible? swish-wpo?)
  (let ([tmp (tmp-filename source-fn)])
    (on-exit (rm-f tmp)
      (compile-imported-libraries #t)
      (generate-wpo-files #t)
      (compile-program source-fn tmp)
      (let* ([wpo-file (string-append (path-root tmp) ".wpo")]
             [libs (compile-whole-program wpo-file output-fn libs-visible?)]
             [missing-libs
              ;; Stand-alone application should have found all required non-swish libraries.
              ;; If swish libraries are incorporated via whole-program optimization,
              ;; then we must also have found the those libraries.
              ;; Dependent applications can use swish libraries included in runtime,
              ;; as can stand-alone applications that explicitly specify --rtlib swish.
              (if swish-wpo?
                  libs
                  (remp swish-lib? libs))])
        (rm-f wpo-file)
        (unless (null? missing-libs)
          (printf "These libraries must be provided at run time:\n~{ ~s\n~}" missing-libs))))))

(define boot-file-map
  (let ([cache #f])
    (lambda ()
      (unless cache
        (set! cache (build-boot-file-map)))
      cache)))

(define (build-boot-file-map)
  (let-values ([(to-stdin from-stdout from-stderr os-pid)
                (spawn-os-process (osi_get_executable_path) '("--verbose") self)])
    (close-port to-stdin)
    (let ([from-stderr (binary->utf8 from-stderr)])
      (let lp ([als '()])
        (let ([line (get-line from-stderr)])
          (if (eof-object? line)
              als
              (lp
               (match (pregexp-match "^trying (.*)\\.\\.\\.opened\r?$" line)
                 [(,_ ,fn)
                  (cons (cons (path-last fn) fn) als)]
                 [,_ als]))))))))

(define (resolve-boot-file boot)
  (cond
   [(regular-file? boot) boot]
   [(assoc boot (boot-file-map)) => cdr]
   [(assoc (string-append boot ".boot") (boot-file-map)) => cdr]
   [else (fail "cannot resolve boot file ~a" boot)]))

(define (resolve-rt-lib rt-lib)
  (cond
   [(regular-file? rt-lib) rt-lib]
   [(equal? rt-lib "swish") swish-library-filename]
   [else (fail "cannot resolve --rtlib ~s" rt-lib)]))

(let ([opt (parse-command-line-arguments cli)])
  (cond
   [(opt "doc") =>
    (lambda (doc-type) (usage (string->symbol doc-type) (opt)))]
   [(opt "help")
    (usage 'help (opt))])
  (let ([source-fn (opt "source-file")]
        [output-fn (opt "output-file")]
        [boot-files (or (opt "boot-files") '())]
        [libdirs (fold-right
                  (lambda (x acc)
                    (append (parse-library x) acc))
                  (library-directories)
                  (or (opt "libdirs") '()))]
        [libs-visible? (opt "libs-visible")]
        [rt-libs (map (lambda (x) (get-real-path (resolve-rt-lib x)))
                   (or (opt "rt-libs") '()))]
        [verbose? (opt "verbose")])
    (define stand-alone? (not (null? boot-files)))
    (unless source-fn
      (fail "requires source filename"))
    (unless output-fn
      (fail "requires output filename"))
    ;; Add location of swish system .wpo files only if we're building a
    ;; stand-alone application (boot-files non-empty).
    (import-notify verbose?)
    (cond
     [stand-alone?
      (let* ([boot-files (map resolve-boot-file boot-files)]
             [swish-wpo?
              (or (null? rt-libs)
                  ;; don't use wpo for swish library if we're including it as a
                  ;; run-time library, else we could duplicate code
                  (not (member swish-library-filename rt-libs)))])
        (library-setup swish-wpo? verbose? libdirs)
        (do-compile source-fn output-fn libs-visible? swish-wpo?)
        (let* ([app-stem (path-root output-fn)]
               [app-boot (string-append app-stem ".boot")])
          (when verbose?
            (printf "making application boot file ~s from:~{\n-b      ~s~}~{\n--rtlib ~s~}\n        ~s\n"
              app-boot boot-files rt-libs source-fn))
          (apply make-boot-file app-boot '() (append boot-files rt-libs (list output-fn)))
          (copy-to output-fn (osi_get_executable_path))))]
     [else
      (library-setup #f verbose? libdirs)
      (do-compile source-fn output-fn libs-visible? #f)
      (let* ([tmp (tmp-filename output-fn)]
             [ip (open-file output-fn O_RDONLY 0 'binary-input)]
             [op (open-file tmp (+ O_WRONLY O_CREAT O_APPEND) #o777 'binary-output)])
        (on-exit (begin (close-port ip) (close-port op))
          (put-bytevector op (string->utf8 "#!/usr/bin/env swish\n"))
          (for-each
           (lambda (rt-lib)
             (unless (equal? rt-lib swish-library-filename)
               (let ([ip (open-file rt-lib O_RDONLY 0 'binary-input)])
                 (on-exit (close-port ip)
                   (copy ip op)))))
           rt-libs)
          (copy ip op))
        (rename-path tmp output-fn))])))
