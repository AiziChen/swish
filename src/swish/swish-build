#!/usr/bin/env swish

;;; Copyright 2018 Beckman Coulter, Inc.
;;;
;;; Permission is hereby granted, free of charge, to any person
;;; obtaining a copy of this software and associated documentation
;;; files (the "Software"), to deal in the Software without
;;; restriction, including without limitation the rights to use, copy,
;;; modify, merge, publish, distribute, sublicense, and/or sell copies
;;; of the Software, and to permit persons to whom the Software is
;;; furnished to do so, subject to the following conditions:
;;;
;;; The above copyright notice and this permission notice shall be
;;; included in all copies or substantial portions of the Software.
;;;
;;; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
;;; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
;;; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
;;; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
;;; HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
;;; WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
;;; OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
;;; DEALINGS IN THE SOFTWARE.

(define help-sections '(all details examples))

(define cli
  (cli-specs
   ["output-file" -o (string "<output>") "write output to <output>"]
   ["libdirs" -L (list "<libdir>") "add <libdir> to library-directories"]
   ["boot-files" -b (list "<boot-file>")
    "make stand-alone application including <boot-file>"]
   ["libs-visible" --libs-visible bool
    "make imported libraries visible to eval"]
   ["rt-libs" --rtlib (list "<lib>")
    "add compiled library to stand-alone boot file"]
   ["source-file" (string "<source>") "source filename"]
   ["verbose" -v bool "enable verbose build output"]
   ["help" -h --help (list "[<section>]" ...)
    (format "display help, <section>={~{~a~^|~}}" help-sections)]))

(define swish-lib?
  (let ([libs (filter (lambda (lib) (match lib [(swish . ,_) #t] [,_ #f])) (library-list))])
    (lambda (lib)
      (member lib libs))))

(define swish-libdir (path-parent (osi_get_executable_path)))

(define (system-libdir swish-wpo?)
  (path-combine swish-libdir (if swish-wpo? "wpo" "lib")))

(define swish-library-filename
  (get-real-path (path-combine swish-libdir "swish.library")))

(define (library-setup swish-wpo? verbose? libdirs)
  (library-directories (cons (system-libdir swish-wpo?) libdirs))
  (when verbose?
    (printf "Library directories:\n~{ ~s\n~}" (library-directories))))

(define who (path-last (car (command-line))))

(define (fail fmt . args) (apply errorf who fmt args))

(define (wrap indent . texts)
  (wrap-text (current-output-port)
    (- (help-wrap-width) indent) indent indent (join texts #\space)))

(define-syntax example
  (syntax-rules ()
    [(_ (call ...) text ...)
     (begin
       (wrap 2 call ... "\n")
       (wrap 4 text ... "\n"))]))

(define-syntax any-sections
  (syntax-rules ()
    [(_ requested [(key ...) body ...] ...)
     (let ([sections requested])
       (define thunks
         (remq #f
           (list
            (and (ormap (lambda (x) (memq x sections)) '(key ...))
                 (lambda () body ...))
            ...)))
       (do ([ps thunks (cdr ps)] [sep "" "\n"]) ((null? ps))
         (display sep)
         ((car ps))))]))

(define (list-item item . texts)
  (printf "~4@a " item)
  (wrap-text (current-output-port) (- (help-wrap-width) 6) 0 5 (join texts #\space))
  (newline))

(define (usage short? sections ht)
  (define selected
    (cond
     [(pair? sections) sections]
     [short? '(usage)]
     [else '(usage help)]))
  (any-sections selected
    [(all usage)
     (display-usage "Usage:" who cli)]
    [(all help)
     (when ht (hashtable-delete! ht "help"))
     (display-options cli)]
    [(all details)
     (wrap 0
       who "can make a stand-alone application or a linked application.\n"
       "\n"
       "If -b is specified," who "creates a stand-alone application"
       "by copying the" software-internal-name "executable to <out-file>"
       "and creating a boot file <out-file>.boot containing each"
       (format "-b~aboot-file" #\240)
       "in order, along with the libraries required by source-fn and the"
       "application code from source-fn, and the run-time libraries included"
       "via --rtlib.\n"
       "\n"
       "A stand-alone application executes by:\n")
     (list-item "1." "loading the application boot file, then")
     (list-item "2."
       "invoking the value of the swish-start parameter"
       "with the command-line arguments.")
     (wrap 0
       "The application boot file should customize the swish-start parameter.\n"
       "\n"
       "If -b is omitted," who "creates a linked application.\n"
       "To run a linked application," software-internal-name "must be installed on the system.\n\n"
       "A linked application executes by:\n")
     (list-item "1." "loading the standard" software-internal-name "boot file, then")
     (list-item "2." "invoking the default swish-start handler, which")
     (list-item "3." "calls the linked application with the command-line arguments.")]
    [(all examples)
     (printf "Examples:\n")
     (newline)
     (example (who "-o foo -b petite foo.ss")
       "builds a stand-alone \"foo\" executable from \"foo.ss\""
       "using the same petite.boot that swish uses.\n")
     (example (who "-o foo -b petite -b scheme foo.ss")
       "builds a stand-alone \"foo\" executable from \"foo.ss\" using"
       "the same petite.boot and scheme.boot that swish uses."
       "If we specified only -b scheme, the resulting foo.boot would"
       "not be truly stand-alone, since scheme.boot requires petite.boot.\n")
     (example (who "-o foo -b petite -b scheme --rtlib swish foo.ss")
       "builds a stand-alone \"foo\" executable from \"foo.ss\" using the"
       "same petite.boot and scheme.boot that swish uses and makes the"
       "standard swish libraries available at run time, so that \"foo\""
       "can compile code that uses those libraries.")])
  (let ([invalid (fold-right remq sections help-sections)])
    (unless (null? invalid)
      (fail "unrecognized help section~p:~{ ~a~}" (length invalid) invalid)))
  (exit 0))

(define (parse-library lib)
  (parameterize ([library-directories lib])
    (library-directories)))

;; create tmp file:
;;  - on the same filesystem as basis, else rename-path will fail
;;  - with known extension, since compile-whole-program replaces
;;    extension with .wpo
(define (tmp-filename basis)
  (format "~a-~36r.tmp" (path-root basis)
    (bytevector-uint-ref (osi_make_uuid) 0 'little 16)))

(define (copy ip op)
  (define buflen (expt 2 16))
  (define buf (make-bytevector buflen))
  (let cp ()
    (let ([n (get-bytevector-n! ip buf 0 buflen)])
      (unless (eof-object? n)
        (put-bytevector op buf 0 n)
        (cp)))))

(define (copy-to output-fn . input-fn*)
  ;; open-file applies mode #o777 only when creating the file, so first remove
  (rm-f output-fn)
  (let ([op (open-file output-fn (+ O_WRONLY O_CREAT) #o777 'binary-output)])
    (on-exit (close-port op)
      (for-each
       (lambda (input-fn)
         (let ([ip (open-file input-fn O_RDONLY 0 'binary-input)])
           (on-exit (close-port ip)
             (copy ip op))))
       input-fn*))))

(define (rm-f filename)
  (catch (remove-file filename)))

(define (do-compile source-fn output-fn libs-visible? swish-wpo?)
  (let ([tmp (tmp-filename source-fn)])
    (on-exit (rm-f tmp)
      (compile-imported-libraries #t)
      (generate-wpo-files #t)
      (compile-program source-fn tmp)
      (let* ([wpo-file (string-append (path-root tmp) ".wpo")]
             [libs (compile-whole-program wpo-file output-fn libs-visible?)]
             [missing-libs
              ;; Stand-alone application should have found all required non-swish libraries.
              ;; If swish libraries are incorporated via whole-program optimization,
              ;; then we must also have found the those libraries.
              ;; Dependent applications can use swish libraries included in runtime,
              ;; as can stand-alone applications that explicitly specify --rtlib swish.
              (if swish-wpo?
                  libs
                  (remp swish-lib? libs))])
        (rm-f wpo-file)
        (unless (null? missing-libs)
          (printf "These libraries must be provided at run time:\n~{ ~s\n~}" missing-libs))))))

(define boot-file-map
  (let ([cache #f])
    (lambda ()
      (unless cache
        (set! cache (build-boot-file-map)))
      cache)))

(define (build-boot-file-map)
  (let-values ([(to-stdin from-stdout from-stderr os-pid)
                (spawn-os-process (osi_get_executable_path) '("--verbose") self)])
    (close-port to-stdin)
    (let ([from-stderr (binary->utf8 from-stderr)])
      (let lp ([als '()])
        (let ([line (get-line from-stderr)])
          (if (eof-object? line)
              als
              (lp
               (match (pregexp-match "^trying (.*)\\.\\.\\.opened\r?$" line)
                 [(,_ ,fn)
                  (cons (cons (path-last fn) fn) als)]
                 [,_ als]))))))))

(define (resolve-boot-file boot)
  (cond
   [(regular-file? boot) boot]
   [(assoc boot (boot-file-map)) => cdr]
   [(assoc (string-append boot ".boot") (boot-file-map)) => cdr]
   [else (fail "cannot resolve boot file ~a" boot)]))

(define (resolve-rt-lib rt-lib)
  (cond
   [(regular-file? rt-lib) rt-lib]
   [(equal? rt-lib "swish") swish-library-filename]
   [else (fail "cannot resolve --rtlib ~s" rt-lib)]))

(let ([opt (parse-command-line-arguments cli)])
  (cond
   [(zero? (hashtable-size (opt))) (usage #t '() #f)]
   [(opt "help") =>
    (lambda (sections)
      (usage #f (map string->symbol sections) (opt)))])
  (let ([source-fn (opt "source-file")]
        [output-fn (opt "output-file")]
        [boot-files (or (opt "boot-files") '())]
        [libdirs (fold-right
                  (lambda (x acc)
                    (append (parse-library x) acc))
                  (library-directories)
                  (or (opt "libdirs") '()))]
        [libs-visible? (opt "libs-visible")]
        [rt-libs (map (lambda (x) (get-real-path (resolve-rt-lib x)))
                   (or (opt "rt-libs") '()))]
        [verbose? (opt "verbose")])
    (define stand-alone? (not (null? boot-files)))
    (unless source-fn
      (fail "requires source filename"))
    (unless output-fn
      (fail "requires output filename"))
    ;; Add location of swish system .wpo files only if we're building a
    ;; stand-alone application (boot-files non-empty).
    (import-notify verbose?)
    (cond
     [stand-alone?
      (let* ([boot-files (map resolve-boot-file boot-files)]
             [swish-wpo?
              (or (null? rt-libs)
                  ;; don't use wpo for swish library if we're including it as a
                  ;; run-time library, else we could duplicate code
                  (not (member swish-library-filename rt-libs)))])
        (library-setup swish-wpo? verbose? libdirs)
        (do-compile source-fn output-fn libs-visible? swish-wpo?)
        (let* ([app-stem (path-root output-fn)]
               [app-boot (string-append app-stem ".boot")])
          (when verbose?
            (printf "making application boot file ~s from:~{\n-b      ~s~}~{\n--rtlib ~s~}\n        ~s\n"
              app-boot boot-files rt-libs source-fn))
          (apply make-boot-file app-boot '() (append boot-files rt-libs (list output-fn)))
          (copy-to output-fn (osi_get_executable_path))))]
     [else
      (library-setup #f verbose? libdirs)
      (do-compile source-fn output-fn libs-visible? #f)
      (let* ([tmp (tmp-filename output-fn)]
             [ip (open-file output-fn O_RDONLY 0 'binary-input)]
             [op (open-file tmp (+ O_WRONLY O_CREAT O_APPEND) #o777 'binary-output)])
        (on-exit (begin (close-port ip) (close-port op))
          (put-bytevector op (string->utf8 "#!/usr/bin/env swish\n"))
          (for-each
           (lambda (rt-lib)
             (unless (equal? rt-lib swish-library-filename)
               (let ([ip (open-file rt-lib O_RDONLY 0 'binary-input)])
                 (on-exit (close-port ip)
                   (copy ip op)))))
           rt-libs)
          (copy ip op))
        (rename-path tmp output-fn))])))
